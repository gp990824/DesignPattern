运行时数据区包括:
    堆空间(heap area) 是存储的单位
        新生代
            Eden
            s0
            s1
        老年代
    本地方法栈(native method stack)
        本地方法的调用,存在OOM异常,不会GC
        与本地方法接口,本地方法库打交道
        当某个线程进入一个本地方法的时候,他就进入了一个全新的且不再被jvm限制的世界,它和虚拟机拥有同样的权限
            本地方法可以通过本地方法接口来访问虚拟机内部运行时数据区
            可以直接使用本地处理器的PC寄存器
            直接从本地内存的堆中分配任意数量的内存
        并不是所有的jvm都支持本地方法,因为java虚拟机规范并没有明确要求本地方法栈的使用语言,具体实现方法,数据结构等
        在HotSpot中,将本地方法栈与虚拟机栈合二为一了

    虚拟机栈(stack area)  是运行时的单位,是线程私有的
        保存的是一个一个的栈帧(Stack Frame),一个栈帧就是一个方法  方法的结束方式: return 出现未捕获的异常
        作用: 主管java程序的运行,它保存方法的局部变量(8种基本数据类型,对象的引用地址),部分结果,并参与方法的调用和返回.
        存在StackOverflowError,OOM异常,不会进行GC操作
        可以使用-Xss设置线程中栈的内存大小
        栈帧分为这几个部分:
            局部变量表(local variable)
                定义为一个数字数组,主要用于存储方法参数和定义在方法体内的局部变量,这些数据类型包括基本类型,引用类型,以及返回值类型
                局部变量表的内存大小在编译的时候就确定好了的,无法更改
                局部变量表基本存储单元是Slot(单元槽)
                在局部变量表中,32位占一个槽,64位(double,long)占连个槽,
                    引用类型,byte,char,short,float,boolean(这些基本类型都转为int)都占一个槽
                非静态方法的局部变量表第一个位置放的是 this变量 ,所以静态方法中不能存在this变量,所以不能使用this关键字
                局部变量表中的槽是可以回收的,当执行到某个变量的作用域外后,该内存可以覆盖,达到节省资源的目的
                局部变量表中的变量也是重要的垃圾回收根节点,只要被局部变量表中直接或间接引用的对象都不会被回收
                局部变量表是否为线程安全的?
                    虽然每个线程都分配了一个局部变量表,仍然存在线程不安全的问题,如果局部变量被返回出去,没有在方法内死亡
                    则可能存在线程不安全的问题,如果局部变量的作用域只在方法内,且没有返回出去,则该方法的局部变量表是线程安全的


            操作数栈(operand stack),也叫表达式栈, 底层是用数组来说实现的
                在方法执行的过程当中,根据字节码指令,往栈中写入数据或者提取数据,即pop/push
                主要保存计算过程中的结果,同时作为计算过程中变量临时的存储空间,不能通过访问索引的方式来访问数据
                操作栈所需的大小在编译的时候就确定了,同样32位占一个栈单位,64位占两个栈单位

            动态链接(dynamic liking),也叫指向运行时常量池的方法引用
                每一个栈帧内部包含一个指向运行时常量池中该栈帧所属方法的引用
                动态链接的作用就是将运行时常量池中的符号引用转换成方法的直接调用
                为什么需要常量池?
                    就是为了提供一些符号和常量,便于指令的识别
                方法的调用:
                    动态链接:(对应后期绑定)
                        被调用的方法无法在编译的时候被确定,只能在运行的时候根据实际情况来调用对应的方法
                    静态链接:(对应前期绑定)
                        被调用的方法在编译的时候就确定下来了,在运行的时候保持不变
                    虚方法:在编译的时候不能确定方法的调用版本(在多态机制中体现)
                    非虚方法:与虚方法相反,被static,final,private修饰,实例构造器,父类方法都不能被重写,这些方法称为非虚方法
                    字节码指令:
                        invokevirtual: 调用虚方法
                        invokestatic: 调用静态方法(非虚方法)
                        invokespecial: 调用<init>方法,私有及父类方法,解析阶段确定版本(非虚方法)
                        invokeinterface: 调用接口方法(也是虚方法)
                        invokedynamic: 动态解析出需要调用的方法,然后执行,为了实现动态类型语言(使用Lambda表达式)
                        方法返回地址(return address),也叫方法正常退出或则异常退出的定义

            方法返回地址(return address),也叫方法正常退出或则异常退出的定义
                存储调用该方法PC寄存器的值,
                在方法正常退出后,   *调用者的pc寄存器的值作为返回地址*   ,则调用该方法的指令的下一条指令的地址
                如果异常退出,返回地址通过异常表来确定,栈帧中一般不会保存着部分的信息
                区别在于:
                    异常退出的方法不会给它的调用者任何返回值
            一些附加信息
    程序计数器(PC寄存器)(program counter register)
        用来存储指向下一条指令的地址,也即将要执行的指令代码,由执行引擎读取下一条指令
        唯一个不会抛出OutOtMemoryError(OOM)的区域,不会进行GC操作
        为什要用PC寄存器存储字节码指令地址?
            因为cpu在运行的时候,是不断的切换多个线程的,这时候如果回到了该线程,就必须知道接下来从哪里继续执行指令
    方法区(jdk7及以前称为永久代,也叫元空间)(method area)
    其中: 堆区和方法区与jvm的生命周期一致(即jvm进程只分配一个堆区和方法区),其余的每个线程分配一份

变量:
    成员变量 在使用前可以不赋初值
        类变量(被static修饰)  在liking过程的prepare阶段就已经被赋了默认值 initialization阶段<clinit>()中给类变量显示赋值
        实例变量 在对象呗创建的过程中,会在堆空间分配实例变量空间,并进行默认赋值
    局部变量
        在使用前必须赋初值
